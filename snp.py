import globes
import broad
from variant import VariantList,Variant,BaseCall

class SNP(Variant) :
    def __init__( self, broad_info, calls ) :
        Variant.__init__(self)
        #initial fields only store the data from the Broad VCF
        #as we get annotation data will add it in 
        self.fields = broad_info
        self.base_calls = calls

    def toString( self ) :
        fieldstr = []
        for f in self.fields :
            fieldstr.append( "%s : %s" % (f,self.fields[f]) )
        fieldstr = '\n'.join( fieldstr )

        istr = []
        for i in self.isoforms :
            istr.append( "%s" % i.toString() )
        istr = '\n------------\n-'.join( istr )
        s = \
'''\n###############################################\n
Fields: \n%s\n
Isoforms: \n%s''' % (fieldstr, istr )
        return s

    def sharedByPatients( patient_ixs ) :
        num_mutated = sum( [self.base_calls[pix].isMutated() \
                            for pix in patient_ixs] )
        return num_mutated == len(patient_ixs)

class SNPList(VariantList) :
    def __init__(self, vcf_file) :
        VariantList.__init__(self, vcf_file)
        self.count = 0
        self.homrefs = 0
        #self.build( vcf_file, self.makeSNP )

    def maker( self, splt ) :
        indexOf = broad.COLUMN_MAP
        #if self.count % 9999 == 0 :
            #print "Constructed: %d SNPs" % self.count
        self.count += 1

        broad_calls = splt[ broad.CALL_START: ]
        base_calls = []
        for pat_ix,c in enumerate(broad_calls) :
            sc = broad.splitCall(c)
            gt = broad.convertGT( sc )
            if broad.isMutated( gt ) or broad.noInf( gt ) :
                base_calls.append( BaseCall(sc,pat_ix) )
            else :
                self.homrefs += 1

        broad_info = {}
        keys = broad.COLUMN_MAP.keys()
        for k in keys :
            if k == "chrom" :
                broad_info[k] = globes.chromNum( splt[indexOf[k]] )
            elif k == "info" :
                dinfo = broad.makeInfoDict( splt[ indexOf[k] ] )
                broad_info["AF"] = dinfo["AF"]
            else :
                broad_info[k] = splt[ indexOf[k] ]


        #according to: http://www.broadinstitute.org/gsa/wiki/index.php/Understanding_the_Unified_Genotyper's_VCF_files
        #ref and alt are always given for the forward strand
        broad_info['strand'] = True

        return SNP( broad_info, base_calls )

def outputSNPs( pat_ix, SNPList, out_filename ) :
    fout = open( out_filename, 'wb' )
    tab = "\t"

    columns = ["Chr","Pos","New_Loc","ID","Strand","RefNT","AltNT",\
               "Unique","Unique w/ Low Cov.","GT/Family Info",\
               "Codon Change","AA Change","Side Chain Polarity/Charge",\
               "AA Position","Gene Symbol","Gene Name","Transcript ID",\
               "SIFT","SIFT P-val","GERP","PhastCons","PolyPhen","OMIM",\
               "HGMD_SNP","HGMD_Gene","Domains","dbSNP Genotype Counts",\
               "Allele Counts"] + patients

    fout.write( tab.join( columns ) )
    for i,snp in enumerate( SNPList ) :
        #computate: same_loc, strand, shares, unsure, gt_dp_qlty and cdna_prot

        lout = \
        [snp.chrom, snp.genomicLoc, same_loc, snp.dbSNP, strand, snp.refNT, \
         snp.mutNT, shares, unsure, gt_dp_qlty, cdna_prot, snp.geneName, \
         snp.fullName, snp.transcriptID, snp.SIFT, snp.SIFTProb, snp.GERP, \
         snp.phastCons, snp.polyPhen, snp.OMIM, snp.HGMD_SNP, snp.HGMD_Gene, \
         snp.Domains, snp.GTCounts, snp.AlleleCounts, snp.full_shares]

        fout.write( "%s\n" % "\t".join( lout ) )
        fout.close()

def inputSNPS( vcf_filename ) :
    print "Inputting SNP data\n"

    #maps 3 letter codons to 1 letter code, unused in Gleeson100.cpp
    #codonTable = getCodonTable()

    fin = open( vcf_filename, "rb" )
    patients = broad.getPatients( fin )
    indexOf = broad.BROAD_COLUMN_MAP

    printColumnWarning( vcf_filename, indexOf )

    tot = 0
    SNPList = []

    for dataline in fin.readlines() :
        #will hold the first 9 columns of data, everything remaining into 9
        splt = dataline.strip().split("\t",9)

        #collect all the BaseCalls generated by this dataline
        #We may generate multiple SNP objects for this dataline,
        #so we will want each one to know about the base calls
        base_calls = []
        for family in splt[ indexOf["calls"] ].split('\t') :
            call_splt = broad.splitCall( family )
            if call_splt :
                bc = BaseCall(call_splt)
            else :
                bc = BaseCall()
            base_calls.append( bc )

        assert( len(patients) == len(base_calls) )

        dinfo = makeInfoDict( splt[ indexOf["info"] ] )

        #if there are X multiple matches, there are X different keys for each
        #archetypal attribute on each line.  Break these up into X separate 
        #SNPs objects.  ACCORDING TO BROAD: DO NOT DO THIS. THE ANNOTATIONS
        # ARE NOT RELIABLE.  Look into SNPEff instead
        num_matching = 1
        k1 = "refseq.numMatchingRecords"
        if k1 in dinfo : num_matching = int(dinfo[k1])

        for i in range(1,num_matching+1) :
            tot += 1

            #make a new SNP and fill it with data
            snp = SNP()
            snp.chrom = splt[ indexOf["chrom" ] ]
            snp.genomicLoc = splt[ indexOf["pos"] ]
            snp.dbSNP = splt[ indexOf["dbSNP"] ]
            snp.refNT = splt[ indexOf["ref"] ]
            snp.mutNT = splt[ indexOf["mut"] ]
            snp.info = splt[ indexOf["info"] ]
            snp.calls = base_calls

            if num_matching == 1 : suffix = ""
            else : suffix = "_%d" % i

            k = "refseq.name" + suffix
            if k in dinfo : snp.transcriptID = dinfo[k]
            else : snp.transcriptID = ""

            k = "refseq.name2" + suffix
            if k in dinfo : snp.geneName = dinfo[k]
            else : snp.geneName = ""

            k = "refseq.transcriptStrand" + suffix
            if k in dinfo : snp.strand = dinfo[k] == '+'
            else : snp.strand = True

            k1,k2 = "refseq.codingCoordStr" + suffix,\
                    "refseq.positionType" + suffix
            if k1 in dinfo and (k2 in dinfo and dinfo[k2] == "CDS") :
                snp.codonPos = stripNonNumbers( dinfo[k1] )
                snp.codonStart = snp.codonPos - (snp.codonPos % 3)
            else :
                snp.codonPos, snp.codonStart = 0,0

            k1,k2 = "refseq.proteinCoordStr" + suffix, \
                    "refseq.positionType" + suffix
            if k1 in dinfo and (k2 in dinfo and dinfo[k2] == "CDS") :
                coordStr = dinfo[k1]
                snp.refAA = coordStr[2]
                snp.mutAA = coordStr[3:-1]
                snp.protPos = coordStr[-1]
            else :
                snp.refAA = 'X';
                snp.mutAA = 'X';
                snp.protPos = 0

            k1 = "refseq.referenceCodon" + suffix
            if k1 in dinfo : snp.codon = dinfo[k1]

            snp.is_splice = False
            k1 = "refseq.spliceDist" + suffix
            if k1 in dinfo :
                snp.spliceDist = int(dinfo[k1])
                if -globes.SPLICE_BUFFER <= snp.spliceDist <= globes.SPLICE_BUFFER  :
                    snp.is_splice = True

            k1 = "refseq.positionType" + suffix
            snp.is_utr = k1 in dinfo and dinfo[k1].lower() == "utr"

            SNPList.append( snp )

    assert len(SNPList) == tot
    print "Inputted: %d SNPs" % len(SNPList)

if __name__ == '__main__' :
    #var_list = SNPList( "%s/raw_data/SNPS_SUBSET.vcf" % globes.DATA_DIR )
    #var_list.outputVCF( "%s/raw_data/recovered_SNP_SUBSET.vcf" \
                         #% globes.DATA_DIR )
    #sa = SIFTAnnotator('snp')
    #sa.annotate( var_list )
    pass
